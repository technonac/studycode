<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="X-UA-Compatible" content="IE=edge">
    <title> TypeScript · PINGGOD</title>
    <meta name="description" content="介绍 TypeScript 的基础用法">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="short icon" href="/favicon.png">
    <link rel="stylesheet" href="/css/apollo.css">
    <link rel="search" type="application/opensearchdescription+xml" href="http://pinggod.com/atom.xml" title="PINGGOD">
</head>
<body>
<div class="wrap">
    <header><a href="/" class="logo-link"><img src="/favicon.png"></a>
        <ul class="nav nav-list">
            <li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li>
            <li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li>
            <li class="nav-list-item"><a href="http://weibo.com/sunchongsheng" target="_blank" class="nav-list-link">WEIBO</a>
            </li>
            <li class="nav-list-item"><a href="https://github.com/pinggod" target="_blank"
                                         class="nav-list-link">GITHUB</a></li>
            <li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li>
        </ul>
    </header>
    <section class="container">
        <div class="post">
            <article class="post-block"><h1 class="post-title">TypeScript</h1>
                <div class="post-info">Jul 10, 2016</div>
                <div class="post-content"><p>TypeScript 是 JavaScript 的超集，为 JavaScript 的生态增加了类型机制，并最终将代码编译为纯粹的 JavaScript
                    代码。类型机制很重要吗？最近的一些项目经历让我觉得这真的很重要。当你陷在一个中大型项目中时（Web
                    应用日趋成为常态），没有类型约束、类型推断，总有种牵一发而动全身的危机和束缚。Immutable.js 和 Angular 2 都在使用 TypeScript
                    做开发，它们都是体量颇大的项目，所以我决定尝试一下 Typescript。此外我们还可以尝试 Facebook 的 Flow，比较一下两者的优劣。Typescript 对 ES6
                    也有良好的支持，目前组内项目使用 Babel 编译 ES6，这也就自然而然的把 TypeScirpt 和 Flow / babel-plugin-tcomb 放在了对立面，也许下一篇文章就是介绍
                    Flow 和 babel-plugin-tcomb。</p>
                    <a id="more"></a>
                    <h2 id="What-and-Why"><a href="#What-and-Why" class="headerlink" title="What and Why"></a>What and
                        Why</h2>
                    <p>如果你想对 TypeScript 有更深入的认识，那么推荐你阅读 Stack Overflow 上的问答 <a
                            href="http://stackoverflow.com/questions/12694530/what-is-typescript-and-why-would-i-use-it-in-place-of-javascript"
                            target="_blank" rel="external">What is TypeScript and why would I use it in place of
                        JavaScript?</a> ，这一节也是对这篇问答的一个简述。</p>
                    <p>虽然 JavaScript 是 ECMAScript 规范的标准实现，但并不是所有的浏览器都支持最新的 ECAMScript 规范，这也就限制了开发者使用最新的 JavaScript /
                        ECMAScript 特性。TypeScript 同样支持最新的 ECMAScript 标准，并能将代码根据需求转换为 ES 3 / 5 / 6，这也就意味着，开发者随时可以使用最新的
                        ECMAScript 特性，比如 module / class / spread operator 等，而无需考虑兼容性的问题。ECMAScript
                        所支持的类型机制非常丰富，包括：interface、enum、hybird type 等等。</p>
                    <p>与 TypeScript 相似的工具语言还有很多，它们主要分为两个阵营，一个是类似 Babel 的阵营，以 JavaScript 的方式编写代码，致力于为开发者提供最新的 ECMAScript
                        特性并将代码编译为兼容性的代码；另一个则是 Coffeescript、Clojure、Dart 等的阵营，它们的语法与 JavaScript 迥然不同，但最终会编译为
                        JavaScript。TypeScript 在这两者之间取得了一种平衡，它既为 JavaScript 增加了新特性，也保持了对 JavaScript 代码的兼容，开发者几乎可以直接将
                        <code>.js</code> 文件重命名为 <code>.ts</code> 文件，就可以使用 TypeScript
                        的开发环境，这种做法一方面可以减少开发者的迁移成本，一方面也可以让开发者快速上手 TypeScript。</p>
                    <p>JavaScript
                        是一门解释型语言，变量的数据类型具有动态性，只有执行时才能确定变量的类型，这种后知后觉的认错方法会让开发者成为调试大师，但无益于编程能力的提升，还会降低开发效率。TypeScript
                        的类型机制可以有效杜绝由变量类型引起的误用问题，而且开发者可以控制对类型的监控程度，是严格限制变量类型还是宽松限制变量类型，都取决于开发者的开发需求。添加类型机制之后，副作用主要有两个：增大了开发人员的学习曲线，增加了设定类型的开发时间。总体而言，这些付出相对于代码的健壮性和可维护性，都是值得的。</p>
                    <p>目前主流的 IDE 都为 TypeScript 的开发提供了良好的支持，比如 Visual Studio / VS Code、Atom、Sublime 和 WebStorm。TypeScript
                        与 IDE 的融合，便于开发者实时获取类型信息。举例来说，通过代码补全功能可以获取代码库中其他函数的信息；代码编译完成后，相关信息或错误信息会直接反馈在 IDE 中……</p>
                    <p>在即将发布的 TypeScript 2.0 版本中，将会有许多优秀的特性，比如对 null 和 undefined 的检查。<code>cannot read property &#39;x&#39;
                        of undefined</code> 和 <code>undefined is not a function</code> 在 JavaScript 中是非常常见的错误。在
                        TypeScript 2.0 中，通过使用 <code>non-nullable</code> 类型可以避免此类错误：<code>let x : number =
                            undefined</code> 会让编译器提示错误，因为 undefined 并不是一个 number，通过 <code>let x : number | undefined =
                            undefined</code> 或 <code>let x : number? = undefined</code> 可以让 x 是一个 nullable（undefined 或
                        null） 的值。如果一个变量的类型是 nullable，那么 TypeScript 编译器就可以通过控制流和类型分析来判定对变量的使用是否安全：</p>
                    <figure class="highlight ts">
                        <table>
                            <tr>
                                <td class="code">
                                    <pre><div class="line"><span class="keyword">let</span> x : <span class="built_in">number</span>?;</div><div
                                            class="line"><span class="keyword">if</span> (x !== <span class="literal">undefined</span>)</div><div
                                            class="line">    <span class="comment">// this line will compile, because x is checked.</span></div><div
                                            class="line">    x += <span class="number">1</span>;</div><div
                                            class="line"></div><div class="line"><span class="comment">// this line will fail compilation, because x might be undefined.    </span></div><div
                                            class="line">x += <span class="number">1</span>;</div></pre>
                                </td>
                            </tr>
                        </table>
                    </figure>
                    <p>TypeScript 编译器既可以将 source map 信息置于生成的 <code>.js</code> 文件中，也可以创建独立的 <code>.map</code>
                        文件，便于开发者在代码运行阶段设置断点、审查变量。此外，TypeScript 还可以使用 decorator 拦截代码，为不同的模块系统生成模块加载代码，解析 JSX 等。</p>
                    <h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2>
                    <p>这一节介绍 TypeScirpt 的一些基础特性，算是抛砖引玉，希望引起大家尝试和使用 TypeScript 的兴趣。首先，从最简单的类型标注开始：</p>
                    <figure class="highlight ts">
                        <table>
                            <tr>
                                <td class="code">
                                    <pre><div class="line"><span class="comment">// 原始值</span></div><div
                                            class="line"><span class="keyword">const</span> isDone: <span
                                            class="built_in">boolean</span> = <span class="literal">false</span>;</div><div
                                            class="line"><span class="keyword">const</span> amount: <span
                                            class="built_in">number</span> = <span class="number">6</span>;</div><div
                                            class="line"><span class="keyword">const</span> address: <span
                                            class="built_in">string</span> = <span
                                            class="string">'beijing'</span>;</div><div class="line"><span
                                            class="keyword">const</span> greeting: <span class="built_in">string</span> = <span
                                            class="string">`Hello World`</span>;</div><div class="line"></div><div
                                            class="line"><span class="comment">// 数组</span></div><div class="line"><span
                                            class="keyword">const</span> list: <span class="built_in">number</span>[] = [<span
                                            class="number">1</span>, <span class="number">2</span>, <span
                                            class="number">3</span>];</div><div class="line"><span
                                            class="keyword">const</span> list: <span
                                            class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span
                                            class="number">1</span>, <span class="number">2</span>, <span
                                            class="number">3</span>];</div><div class="line"></div><div
                                            class="line"><span class="comment">// 元组</span></div><div class="line"><span
                                            class="keyword">const</span> name: [<span
                                            class="built_in">string</span>, <span
                                            class="built_in">string</span>] = [<span class="string">'Sean'</span>, <span
                                            class="string">'Sun'</span>];</div><div class="line"></div><div
                                            class="line"><span class="comment">// 枚举</span></div><div class="line"><span
                                            class="keyword">enum</span> Color &#123;</div><div
                                            class="line">    Red,</div><div class="line">    Green,</div><div
                                            class="line">    Blue</div><div class="line">&#125;;</div><div class="line"><span
                                            class="keyword">const</span> c: Color = Color.Green;</div><div
                                            class="line"></div><div class="line"><span
                                            class="comment">// 任意值：可以调用任意方法</span></div><div class="line"><span
                                            class="keyword">let</span> anyTypes: <span
                                            class="built_in">any</span> = <span class="number">4</span>;</div><div
                                            class="line">anyTypes = <span class="string">'any'</span>;</div><div
                                            class="line">anyTypes = <span class="literal">false</span></div><div
                                            class="line"></div><div class="line"><span
                                            class="comment">// 空值</span></div><div class="line"><span
                                            class="function"><span class="keyword">function</span> <span class="title">doSomething</span> (<span
                                            class="params"></span>): <span class="title">void</span> </span>&#123;</div><div
                                            class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</div><div
                                            class="line">&#125;</div><div class="line"></div><div class="line"><span
                                            class="comment">// 类型断言</span></div><div class="line"><span class="keyword">let</span> someValue: <span
                                            class="built_in">any</span> = <span class="string">"this is a string"</span>;</div><div
                                            class="line"><span class="keyword">let</span> strLength: <span
                                            class="built_in">number</span> = (someValue as <span
                                            class="built_in">string</span>).length;</div></pre>
                                </td>
                            </tr>
                        </table>
                    </figure>
                    <p>TypeScript 中的 Interface 可以看做是一个集合，这个集合是对对象、类等内部结构的约定：</p>
                    <figure class="highlight ts">
                        <table>
                            <tr>
                                <td class="code">
                                    <pre><div class="line"><span class="comment">// 定义接口 Coords</span></div><div
                                            class="line"><span class="comment">// 该接口包含 number 类型的 x，string 类型的 y</span></div><div
                                            class="line"><span class="comment">// 其中 y 是可选类型，即是否包含该属性无所谓</span></div><div
                                            class="line"><span class="keyword">interface</span> Coords &#123;</div><div
                                            class="line">	x: <span class="built_in">number</span>;</div><div
                                            class="line">	y?: <span class="built_in">string</span>;</div><div
                                            class="line">&#125;;</div><div class="line"></div><div class="line"><span
                                            class="comment">// 定义函数 where</span></div><div class="line"><span
                                            class="comment">// 该函数接受一个 Coords 类型的参数 l</span></div><div
                                            class="line"><span class="function"><span
                                            class="keyword">function</span> <span class="title">where</span> (<span
                                            class="params">l: Coords</span>) </span>&#123;</div><div
                                            class="line">	<span class="comment">// doSomething</span></div><div
                                            class="line">&#125;</div><div class="line"></div><div class="line"><span
                                            class="keyword">const</span> a = &#123; x: <span class="number">100</span> &#125;;</div><div
                                            class="line"><span class="keyword">const</span> b = &#123; x: <span
                                            class="number">100</span>, y1: <span
                                            class="string">'abc'</span> &#125;;</div><div class="line"></div><div
                                            class="line"><span
                                            class="comment">// a 拥有 number 类型的 x，可以传递给 where</span></div><div
                                            class="line">where(a);</div><div class="line"><span class="comment">// b 拥有 number 类型的 x 和 string 类型的 y1，可以传递给 where</span></div><div
                                            class="line">where(b);</div><div class="line"></div><div class="line"><span
                                            class="comment">// 下面这种调用方式将会报错，虽然它和 where(b) 看起来是一致的</span></div><div
                                            class="line"><span class="comment">// 区别在于这里传递的是一个对象字面量</span></div><div
                                            class="line"><span class="comment">// 对象字面量会被特殊对待并经过额外的属性检查</span></div><div
                                            class="line"><span
                                            class="comment">// 如果对象字面量中存在目标类型中未声明的属性，则抛出错误</span></div><div
                                            class="line">where(&#123; x: <span class="number">100</span>, y1: <span
                                            class="string">'abc'</span> &#125;);</div><div class="line"></div><div
                                            class="line"><span class="comment">// 最好的解决方式是为接口添加索引签名</span></div><div
                                            class="line"><span
                                            class="comment">// 添加如下所示的索引签名后，对象字面量可以有任意数量的属性</span></div><div
                                            class="line"><span
                                            class="comment">// 只要属性不是 x 和 y，其他属性可以是 any 类型</span></div><div
                                            class="line"><span class="keyword">interface</span> Coords &#123;</div><div
                                            class="line">	x: <span class="built_in">number</span>;</div><div
                                            class="line">	y?: <span class="built_in">string</span>;</div><div
                                            class="line">    [propName: <span class="built_in">string</span>]: <span
                                            class="built_in">any</span></div><div class="line">&#125;;</div></pre>
                                </td>
                            </tr>
                        </table>
                    </figure>
                    <p>上面的代码演示了接口对对象的约束，此外，接口还常用于约束函数的行为：</p>
                    <figure class="highlight ts">
                        <table>
                            <tr>
                                <td class="code">
                                    <pre><div class="line"><span class="comment">// CheckType 包含一个调用签名</span></div><div
                                            class="line"><span class="comment">// 该调用签名声明了 getType 函数需要接收一个 any 类型的参数，并最终返回一个 string 类型的结果</span></div><div
                                            class="line"><span class="keyword">interface</span> CheckType &#123;</div><div
                                            class="line">    (data: <span class="built_in">any</span>): <span
                                            class="built_in">string</span>;</div><div class="line">&#125;;</div><div
                                            class="line"></div><div class="line"><span class="keyword">const</span> getType: CheckType = (data: <span
                                            class="built_in">any</span>) : <span class="built_in">string</span> =&gt; &#123;</div><div
                                            class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(data);</div><div
                                            class="line">&#125;</div><div class="line"></div><div
                                            class="line">getType(<span class="string">'abc'</span>);</div><div
                                            class="line"><span
                                            class="comment">// =&gt; '[object String]'</span></div></pre>
                                </td>
                            </tr>
                        </table>
                    </figure>
                    <p>与老牌强类型语言 C#、Java 相同的是，Interface 也可以用于约束类的行为：</p>
                    <figure class="highlight ts">
                        <table>
                            <tr>
                                <td class="code">
                                    <pre><div class="line"><span class="keyword">interface</span> ClockConstructor &#123;</div><div
                                            class="line">    <span class="keyword">new</span> (hour: <span
                                            class="built_in">number</span>, minute: <span class="built_in">number</span>): ClockInterface;</div><div
                                            class="line">&#125;</div><div class="line"><span
                                            class="keyword">interface</span> ClockInterface &#123;</div><div
                                            class="line">    tick();</div><div class="line">&#125;</div><div
                                            class="line"></div><div class="line"><span class="function"><span
                                            class="keyword">function</span> <span class="title">createClock</span>(<span
                                            class="params">ctor: ClockConstructor, hour: <span
                                            class="built_in">number</span>, minute: <span class="built_in">number</span></span>): <span
                                            class="title">ClockInterface</span> </span>&#123;</div><div class="line">    <span
                                            class="keyword">return</span> <span class="keyword">new</span> ctor(hour, minute);</div><div
                                            class="line">&#125;</div><div class="line"></div><div class="line"><span
                                            class="keyword">class</span> DigitalClock <span
                                            class="keyword">implements</span> ClockInterface &#123;</div><div
                                            class="line">    <span class="keyword">constructor</span>(h: number, m: number) &#123; &#125;</div><div
                                            class="line">    tick() &#123;</div><div class="line">        <span
                                            class="built_in">console</span>.log(<span class="string">"beep beep"</span>);</div><div
                                            class="line">    &#125;</div><div class="line">&#125;</div><div
                                            class="line"><span class="keyword">class</span> AnalogClock <span
                                            class="keyword">implements</span> ClockInterface &#123;</div><div
                                            class="line">    <span class="keyword">constructor</span>(h: number, m: number) &#123; &#125;</div><div
                                            class="line">    tick() &#123;</div><div class="line">        <span
                                            class="built_in">console</span>.log(<span class="string">"tick tock"</span>);</div><div
                                            class="line">    &#125;</div><div class="line">&#125;</div><div
                                            class="line"></div><div class="line"><span class="keyword">let</span> digital = createClock(DigitalClock, <span
                                            class="number">12</span>, <span class="number">17</span>);</div><div
                                            class="line"><span class="keyword">let</span> analog = createClock(AnalogClock, <span
                                            class="number">7</span>, <span class="number">32</span>);</div></pre>
                                </td>
                            </tr>
                        </table>
                    </figure>
                    <h4 id="class"><a href="#class" class="headerlink" title="class"></a>class</h4>
                    <p>除了 ES6 增加的 Class 用法，TypeScript 还增加了 C++、Java 中常见的 public / protected / private
                        限定符，限定变量或函数的使用范围。TypeScript 使用的是结构性类型系统，只要两种类型的成员类型相同，则认为这两种类型是兼容和一致的，但比较包含 private 和 protected
                        成员的类型时，只有他们是来自同一处的统一类型成员时才会被认为是兼容的：</p>
                    <figure class="highlight ts">
                        <table>
                            <tr>
                                <td class="code">
                                    <pre><div class="line"><span class="keyword">class</span> Animal &#123;</div><div
                                            class="line">    <span class="keyword">private</span> name: <span
                                            class="built_in">string</span>;</div><div class="line">    <span
                                            class="keyword">constructor</span>(theName: string) &#123; <span
                                            class="keyword">this</span>.name = theName; &#125;</div><div class="line">&#125;</div><div
                                            class="line"></div><div class="line"><span class="keyword">class</span> Rhino extends Animal &#123;</div><div
                                            class="line">    <span class="keyword">constructor</span>() &#123; <span
                                            class="keyword">super</span>(<span
                                            class="string">"Rhino"</span>); &#125;</div><div class="line">&#125;</div><div
                                            class="line"></div><div class="line"><span class="keyword">class</span> Employee &#123;</div><div
                                            class="line">    <span class="keyword">private</span> name: <span
                                            class="built_in">string</span>;</div><div class="line">    <span
                                            class="keyword">constructor</span>(theName: string) &#123; <span
                                            class="keyword">this</span>.name = theName; &#125;</div><div class="line">&#125;</div><div
                                            class="line"></div><div class="line"><span class="keyword">let</span> animal = <span
                                            class="keyword">new</span> Animal(<span class="string">"Goat"</span>);</div><div
                                            class="line"><span class="keyword">let</span> rhino = <span class="keyword">new</span> Rhino();</div><div
                                            class="line"><span class="keyword">let</span> employee = <span
                                            class="keyword">new</span> Employee(<span
                                            class="string">"Bob"</span>);</div><div class="line"></div><div
                                            class="line">animal = rhino;</div><div class="line"><span class="comment">// Error: Animal and Employee are not compatible</span></div><div
                                            class="line">animal = employee;</div></pre>
                                </td>
                            </tr>
                        </table>
                    </figure>
                    <p>抽象类是供其他类继承的基类，与接口不同的是，抽象类可以包含成员方法的实现细节，但抽不可以包含抽象方法的实现细节：</p>
                    <figure class="highlight ts">
                        <table>
                            <tr>
                                <td class="code">
                                    <pre><div class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> Animal &#123;</div><div
                                            class="line">    <span class="comment">// 抽象方法</span></div><div
                                            class="line">    <span class="keyword">abstract</span> makeSound(): <span
                                            class="built_in">void</span>;</div><div class="line">    <span
                                            class="comment">// 成员方法</span></div><div class="line">    move(): <span
                                            class="built_in">void</span> &#123;</div><div class="line">        <span
                                            class="built_in">console</span>.log(<span class="string">'roaming the earch...'</span>);</div><div
                                            class="line">    &#125;</div><div class="line">&#125;</div></pre>
                                </td>
                            </tr>
                        </table>
                    </figure>
                    <h4 id="function"><a href="#function" class="headerlink" title="function"></a>function</h4>
                    <p>添加类型机制的 TypeScript 在函数上最可以秀的一块就是函数重载了：</p>
                    <figure class="highlight ts">
                        <table>
                            <tr>
                                <td class="code">
                                    <pre><div class="line"><span class="keyword">let</span> suits = [<span
                                            class="string">"hearts"</span>, <span class="string">"spades"</span>, <span
                                            class="string">"clubs"</span>, <span
                                            class="string">"diamonds"</span>];</div><div class="line"></div><div
                                            class="line"><span class="function"><span
                                            class="keyword">function</span> <span class="title">pickCard</span>(<span
                                            class="params">x: &#123;suit: <span
                                            class="built_in">string</span>; card: <span class="built_in">number</span>; &#125;[]</span>): <span
                                            class="title">number</span></span>;</div><div class="line"><span
                                            class="function"><span class="keyword">function</span> <span class="title">pickCard</span>(<span
                                            class="params">x: <span class="built_in">number</span></span>): </span>&#123;suit: <span
                                            class="built_in">string</span>; card: <span class="built_in">number</span>; &#125;;</div><div
                                            class="line"><span class="function"><span
                                            class="keyword">function</span> <span class="title">pickCard</span>(<span
                                            class="params">x</span>): <span class="title">any</span> </span>&#123;</div><div
                                            class="line">    <span class="comment">// Check to see if we're working with an object/array</span></div><div
                                            class="line">    <span class="comment">// if so, they gave us the deck and we'll pick the card</span></div><div
                                            class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x == <span
                                            class="string">"object"</span>) &#123;</div><div class="line">        <span
                                            class="keyword">let</span> pickedCard = <span class="built_in">Math</span>.floor(<span
                                            class="built_in">Math</span>.random() * x.length);</div><div class="line">        <span
                                            class="keyword">return</span> pickedCard;</div><div
                                            class="line">    &#125;</div><div class="line">    <span class="comment">// Otherwise just let them pick the card</span></div><div
                                            class="line">    <span class="keyword">else</span> <span
                                            class="keyword">if</span> (<span class="keyword">typeof</span> x == <span
                                            class="string">"number"</span>) &#123;</div><div class="line">        <span
                                            class="keyword">let</span> pickedSuit = <span class="built_in">Math</span>.floor(x / <span
                                            class="number">13</span>);</div><div class="line">        <span
                                            class="keyword">return</span> &#123; suit: suits[pickedSuit], card: x % <span
                                            class="number">13</span> &#125;;</div><div class="line">    &#125;</div><div
                                            class="line">&#125;</div><div class="line"></div><div class="line"><span
                                            class="keyword">let</span> myDeck = [&#123; suit: <span class="string">"diamonds"</span>, card: <span
                                            class="number">2</span> &#125;, &#123; suit: <span
                                            class="string">"spades"</span>, card: <span class="number">10</span> &#125;, &#123; suit: <span
                                            class="string">"hearts"</span>, card: <span class="number">4</span> &#125;];</div><div
                                            class="line"><span class="keyword">let</span> pickedCard1 = myDeck[pickCard(myDeck)];</div><div
                                            class="line"><span class="keyword">let</span> pickedCard2 = pickCard(<span
                                            class="number">15</span>);</div><div class="line"></div><div
                                            class="line"><span class="built_in">console</span>.log(<span class="string">"card: "</span> + pickedCard1.card + <span
                                            class="string">" of "</span> + pickedCard1.suit);</div><div
                                            class="line"><span class="built_in">console</span>.log(<span class="string">"card: "</span> + pickedCard2.card + <span
                                            class="string">" of "</span> + pickedCard2.suit);</div></pre>
                                </td>
                            </tr>
                        </table>
                    </figure>
                    <p>编译器首先会尝试匹配第一个函数重载的声明，如果类型匹配成功就执行，否则继续匹配其他的重载声明，因此参数的针对性越强的函数重载，越要靠前声明。</p>
                    <h4 id="genrics"><a href="#genrics" class="headerlink" title="genrics"></a>genrics</h4>
                    <figure class="highlight ts">
                        <table>
                            <tr>
                                <td class="code">
                                    <pre><div class="line"><span class="function"><span class="keyword">function</span> <span
                                            class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span
                                            class="params">arg: T[]</span>): <span class="title">T</span>[] </span>&#123;</div><div
                                            class="line">    <span
                                            class="built_in">console</span>.log(arg.length);</div><div class="line">    <span
                                            class="keyword">return</span> arg;</div><div class="line">&#125;</div><div
                                            class="line"></div><div class="line"><span class="keyword">let</span> myIdentity: &#123;&lt;T&gt;(arg: T[]): T[]&#125; = identity;</div></pre>
                                </td>
                            </tr>
                        </table>
                    </figure>
                    <p>上面的代码展示了泛型的基本用法，这里的 <code>&lt;T&gt;</code>
                        称为泛型变量，通过这个声明，我们可以确定传入的参数类型和返回的数据类型是一致的，一旦确定了传入的参数类型，也就确定了返回的数据类型。<code>myIdentity</code>
                        使用了带有调用签名的对象字面量定义泛型函数，实际上可以结合接口，写出更简洁的泛型接口：</p>
                    <figure class="highlight ts">
                        <table>
                            <tr>
                                <td class="code">
                                    <pre><div class="line"><span
                                            class="keyword">interface</span> IdentityFn &#123;</div><div class="line">     &lt;T&gt;(arg: T[]): T[];</div><div
                                            class="line">&#125;;</div><div class="line"></div><div class="line"><span
                                            class="keyword">let</span> myIdentity: IdentityFn = identity;</div></pre>
                                </td>
                            </tr>
                        </table>
                    </figure>
                    <p>如果同一个泛型变量在接口中被反复使用，那么可以在定义接口名的同时声明泛型变量：</p>
                    <figure class="highlight ts">
                        <table>
                            <tr>
                                <td class="code">
                                    <pre><div class="line"><span class="keyword">interface</span> IdentityFn&lt;T&gt; &#123;</div><div
                                            class="line">    (arg: T[]): T[];</div><div class="line">&#125;;</div><div
                                            class="line"></div><div class="line"><span class="function"><span
                                            class="keyword">function</span> <span class="title">identity</span>&lt;<span
                                            class="title">T</span>&gt;(<span class="params">arg: T[]</span>): <span
                                            class="title">T</span>[] </span>&#123;</div><div class="line">    <span
                                            class="built_in">console</span>.log(arg.length);</div><div class="line">    <span
                                            class="keyword">return</span> arg;</div><div class="line">&#125;</div><div
                                            class="line"></div><div class="line"><span class="keyword">let</span> myIdentity: IdentityFn&lt;<span
                                            class="built_in">string</span>&gt; = identity;</div></pre>
                                </td>
                            </tr>
                        </table>
                    </figure>
                    <p>在泛型接口之外，还可以使用泛型类，两者的形式非常类似：</p>
                    <figure class="highlight ts">
                        <table>
                            <tr>
                                <td class="code">
                                    <pre><div class="line"><span class="keyword">class</span> GenericNumber&lt;T&gt; &#123;</div><div
                                            class="line">    zeroValue: T;</div><div class="line">    add: (x: T, y: T) =&gt; T;</div><div
                                            class="line">&#125;</div></pre>
                                </td>
                            </tr>
                        </table>
                    </figure>
                    <p>泛型也可以直接继承接口约束自己的行为：</p>
                    <figure class="highlight ts">
                        <table>
                            <tr>
                                <td class="code">
                                    <pre><div class="line"><span
                                            class="keyword">interface</span> Lengthwise &#123;</div><div class="line">    length: <span
                                            class="built_in">number</span>;</div><div class="line">&#125;</div><div
                                            class="line"></div><div class="line"><span class="function"><span
                                            class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span
                                            class="title">T</span> <span class="title">extends</span> <span
                                            class="title">Lengthwise</span>&gt;(<span
                                            class="params">arg: T</span>): <span
                                            class="title">T</span> </span>&#123;</div><div class="line">    <span
                                            class="built_in">console</span>.log(arg.length);</div><div class="line">    <span
                                            class="keyword">return</span> arg;</div><div class="line">&#125;</div></pre>
                                </td>
                            </tr>
                        </table>
                    </figure>
                    <h4 id="type-inference"><a href="#type-inference" class="headerlink" title="type inference"></a>type
                        inference</h4>
                    <p>TypeScript 主要有两种类型推断方式：Best Common Type 和 Contextual Type。我们先介绍 Best Common Type:</p>
                    <figure class="highlight ts">
                        <table>
                            <tr>
                                <td class="code">
                                    <pre><div class="line"><span class="keyword">let</span> x = [<span
                                            class="number">0</span>, <span class="number">1</span>, <span
                                            class="literal">null</span>];</div></pre>
                                </td>
                            </tr>
                        </table>
                    </figure>
                    <p>对于上面代码中的变量 x，如果要推断出它的类型，就必须充分考虑 <code>[0, 1, null]</code> 的类型，所以这里进行类型推断的顺序是从表达式的叶子到根的，也就是先推断变量 x
                        的值都包含什么类型，然后总结出 x 的类型，是一种从下往上的推断过程。</p>
                    <p>TypeScript 的类型推论也可以按照从上往下的顺序进行，这被称为 <strong>Contextual Type</strong>：</p>
                    <figure class="highlight ts">
                        <table>
                            <tr>
                                <td class="code">
                                    <pre><div class="line"><span class="built_in">window</span>.onmousedown = <span
                                            class="function"><span class="keyword">function</span>(<span class="params">mouseEvent</span>) </span>&#123;</div><div
                                            class="line">    <span class="comment">// Error: Property 'button' does not exist ontype 'MouseEvent'</span></div><div
                                            class="line">    <span class="built_in">console</span>.log(mouseEvent.buton);  </div><div
                                            class="line">&#125;;</div></pre>
                                </td>
                            </tr>
                        </table>
                    </figure>
                    <p>在上面的示例中，TypeScript 类型推断机制会通过 <code>window.onmousedown</code> 函数的类型来推断右侧函数表达式的类型，继而推断出 <code>mouseEvent</code>
                        的类型，这种从上到下的推断顺序就是 <strong>Contextual Type</strong> 的特征。</p>
                    <p>这里只对 TypeScript 的特性做简单的介绍，更详细的资料请参考以下资料：</p>
                    <ul>
                        <li><a href="https://www.typescriptlang.org/docs/tutorial.html" target="_blank" rel="external">TypeScript
                            官方文档</a></li>
                        <li>
                            <a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Basic%20Types.html"
                               target="_blank" rel="external">TypeScript 中文文档</a></li>
                        <li><a href="https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md" target="_blank"
                               rel="external">TypeScript Language Specification</a></li>
                    </ul>
                    <h2 id="React-and-Webpack"><a href="#React-and-Webpack" class="headerlink"
                                                  title="React and Webpack"></a>React and Webpack</h2>
                    <p>在 TypeScript 中开发 React 时有以下几点注意事项：</p>
                    <ul>
                        <li>对 React 文件使用 <code>.tsx</code> 的扩展名</li>
                        <li>在 tsconfig.json 中使用 <code>compilerOptions.jsx: &#39;react&#39;</code></li>
                        <li>使用 typings 类型定义</li>
                    </ul>
                    <figure class="highlight js">
                        <table>
                            <tr>
                                <td class="code">
                                    <pre><div class="line">interface Props &#123;</div><div class="line">    <span
                                            class="attr">foo</span>: string;</div><div class="line">&#125;</div><div
                                            class="line"></div><div class="line"><span class="class"><span
                                            class="keyword">class</span> <span class="title">MyComponent</span> <span
                                            class="keyword">extends</span> <span class="title">React</span>.<span
                                            class="title">Component</span>&lt;<span class="title">Props</span>, </span>&#123;&#125;&gt; &#123;</div><div
                                            class="line">    render() &#123;</div><div class="line">        <span
                                            class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span
                                            class="name">span</span>&gt;</span>&#123;this.props.foo&#125;<span
                                            class="tag">&lt;/<span class="name">span</span>&gt;</span></span></div><div
                                            class="line">    &#125;</div><div class="line">&#125;</div><div
                                            class="line"></div><div class="line">&lt;MyComponent foo=<span
                                            class="string">"bar"</span> /&gt;; <span class="comment">// 正确</span></div></pre>
                                </td>
                            </tr>
                        </table>
                    </figure>
                    <p>TypeScript 的官方文档中对 React 的开发做了一个简单的演示，主要包含以下几个部分：</p>
                    <ul>
                        <li>使用 tsconfig.json 作为 TypeScript 的编译配置文件</li>
                        <li>使用 webpack 作为构建工具，需要安装 webpack、ts-loader 和 source-map-loader</li>
                        <li>使用 typings 作为代码提示工具</li>
                    </ul>
                    <p>具体的搭建流程可以参考文档 <a href="https://www.typescriptlang.org/docs/handbook/react-&amp;-webpack.html"
                                        target="_blank" rel="external">React &amp; Webpack</a>，此外，我个人写过一个 <a
                            href="https://github.com/pinggod/react-startkit/tree/typescript" target="_blank"
                            rel="external">TypeScript &amp; Webpack &amp; React 开发的最小化模板</a>可供各位参考，与之等同的 <a
                            href="https://github.com/pinggod/react-startkit/tree/babel" target="_blank" rel="external">Babel
                        &amp; Webpack &amp; React 版本</a>。</p>
                    <blockquote>
                        <p>如果查看模板之后对 <code>import * as React from &#39;react&#39;</code> 的方式有所疑惑，请查看 TypeScript 的负责人
                            Anders Hejlsberg 在 <a
                                    href="https://github.com/Microsoft/TypeScript/issues/2242#issuecomment-83694181"
                                    target="_blank" rel="external">issue#2242</a> 中的详细解析。</p>
                    </blockquote>
                    <h6 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h6>
                    <ul>
                        <li><a href="https://www.typescriptlang.org/docs/tutorial.html" target="_blank" rel="external">TypeScript
                            Document</a></li>
                        <li>
                            <a href="http://stackoverflow.com/questions/12694530/what-is-typescript-and-why-would-i-use-it-in-place-of-javascript"
                               target="_blank" rel="external">What is TypeScript and why would I use it in place of
                                JavaScript?</a></li>
                        <li>
                            <a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Basic%20Types.html"
                               target="_blank" rel="external">TypeScript 中文文档</a></li>
                    </ul>
                </div>
            </article>
        </div>
    </section>
    <footer>
        <div class="paginator"><a href="/2016/Flexbox/" class="prev">PREV</a><a href="/2016/Throttle-and-Debounce/"
                                                                                class="next">NEXT</a></div>
        <div class="copyright"><p>© 2015 - 2016 <a href="http://pinggod.com">pinggod</a>, powered by <a
                href="https://hexo.io/" target="_blank">Hexo</a> and <a
                href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div>
    </footer>
</div>
<script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script>(function (b, o, i, l, e, r) {
    b.GoogleAnalyticsObject = l;
    b[l] || (b[l] = function () {
        (b[l].q = b[l].q || []).push(arguments)
    });
    b[l].l = +new Date;
    e = o.createElement(i);
    r = o.getElementsByTagName(i)[0];
    e.src = '//www.google-analytics.com/analytics.js';
    r.parentNode.insertBefore(e, r)
}(window, document, 'script', 'ga'));
ga('create', "UA-65933410-1", 'auto');
ga('send', 'pageview');</script>
</body>
</html>